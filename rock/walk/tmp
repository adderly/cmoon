int member_check_login(HDF *hdf, mdb_conn *conn)
{
	PRE_DBOP(hdf, conn);

	int uin = hdf_get_int_value(hdf, PRE_QUERY".uin", 0);
	char *usn = hdf_get_value(hdf, PRE_QUERY".usn", "");
	int ret;

	if (uin < MIN_USER_NUM || !strcmp(usn, "")) return RET_RBTOP_INPUTE;

	/*
	 * get user info from mmc
	 */
	char *keys[2], keyname[LEN_MMC_KEY], keypass[LEN_MMC_KEY];
	char *vals[2];
	keys[0] = keyname; keys[1] = keypass;
	memset(keyname, 0x0, sizeof(keyname));
	memset(keypass, 0x0, sizeof(keypass));
	snprintf(keyname, sizeof(keyname), "%s.%d.%s", PRE_MMC_LOGIN, uin, PRE_MMC_UNAME);
	snprintf(keypass, sizeof(keypass), "%s.%d.%s", PRE_MMC_LOGIN, uin, PRE_MMC_UPASS);
	rc = mmc_mget(keys, vals, 2, NULL, NULL);
	if (rc != MEMCACHED_SUCCESS || vals[0] == NULL || vals[1] == NULL) {
		/* failure, get from db */
		char *usndb = NULL, *unamedb = NULL;
		char usertable[LEN_TB];
		sprintf(usertable, "user_%d", uin%DIV_USER_TB);
		mdb_exec(conn, NULL, "SELECT usn, uname FROM %s WHERE uin=%d;",
				 NULL, usertable, uin);
		ret = mdb_get(conn, "ss", &usndb, &unamedb);
		if (ret != MDB_ERR_NONE || usndb == NULL || unamedb == NULL) {
			mtc_warn("get user %d's info from db failure", uin);
			return RET_RBTOP_LOGINUSR;
		} else {
			/* ok form db, and set user's info into mmc */
			mtc_dbg("store %d passwd %s into mmc", uin, usndb);
			mmc_store(MMC_OP_ADD, keys[0], unamedb, 0, ONE_MONTH, 0);
			mmc_store(MMC_OP_ADD, keys[1], usndb, 0, ONE_MONTH, 0);
			if (strncmp(usndb, usn, strlen(usndb))) {
				mtc_info("user %d passwd error from db", uin);
				return RET_RBTOP_LOGINPSW;
			} else {
				hdf_set_value(hdf, PRE_QUERY".uname", unamedb);
				return RET_RBTOP_OK;
			}
		}
	} else {
		/* ok from mmc */
		char *unamemmc = vals[0];
		char *usnmmc = vals[1];
		if (strncmp(usnmmc, usn, strlen(usnmmc))) {
			mtc_info("user %d passwd error from mmc %s", uin, usnmmc);
			free(vals[0]); free(vals[1]);
			return RET_RBTOP_LOGINPSW;
		} else {
			hdf_set_value(hdf, PRE_QUERY".uname", unamemmc);
			free(vals[0]); free(vals[1]);
			return RET_RBTOP_OK;
		}
	}
	return RET_RBTOP_OK;
}

void member_after_login(CGI *cgi, mdb_conn *conn)
{
	int uin = hdf_get_int_value(cgi->hdf, PRE_QUERY".uin", 0);
	char *usn = hdf_get_value(cgi->hdf, PRE_QUERY".usn", "");
	char *uname = hdf_get_value(cgi->hdf, PRE_QUERY".uname", "");
	if (uin <= MIN_USER_NUM || !strcmp(usn, "")) return;
	
	char keys[2][LEN_MMC_KEY], key[LEN_MMC_KEY];
	memcached_return rc;

	/*
	 * set user's info intoto cookie
	 */
	cgi_cookie_set(cgi, "uin", hdf_get_value(cgi->hdf, PRE_QUERY".uin", "0"),
				   NULL, SITE_DOMAIN, NULL, 1, 0);
	member_set_unameck(cgi);
	member_remember_login(cgi, conn, uin);

	/*
	 * set user's info into mmc
	 * and update current hour's count, list
	 */
	char tm[LEN_TM];
	mmisc_getdatetime(tm, sizeof(tm), "%F_%H", 0);
	snprintf(keys[0], sizeof(keys[0]), "%s.%d.%s", PRE_MMC_LOGIN, uin, PRE_MMC_UNAME);
	snprintf(keys[1], sizeof(keys[1]), "%s.%d.%s", PRE_MMC_LOGIN, uin, PRE_MMC_UPASS);
	rc = mmc_store(MMC_OP_ADD, keys[0], uname, 0, ONE_MONTH, 0);
	rc = mmc_store(MMC_OP_ADD, keys[1], usn, 0, ONE_MONTH, 0);
	if (rc == MEMCACHED_SUCCESS) {
		snprintf(key, sizeof(key), "%s.Count.%s", PRE_MMC_LOGIN, tm);
		mmc_count(MMC_OP_INC, key, 1, NULL, ONE_WEEK, 0);
		
		snprintf(key, sizeof(key), "%s.List.%s", PRE_MMC_LOGIN, tm);
		char val[LEN_INT];
		sprintf(val, "%d ", uin);
		mmc_store(MMC_OP_APP, key, val, 0, ONE_WEEK, 0);
	} else if (rc == MEMCACHED_NOTSTORED) {
		rc = mmc_store(MMC_OP_REP, keys[0], uname, 0, ONE_WEEK, 0);
		rc = mmc_store(MMC_OP_REP, keys[1], usn, 0, ONE_WEEK, 0);
	}
	if (rc != MEMCACHED_SUCCESS) {
		mtc_warn("store %d's info into mmc failure", uin);
	}

	/*
	 * set user info into hdf
	 */
	hdf_set_copy(cgi->hdf, PRE_OUTPUT".uin", PRE_QUERY".uin");
	hdf_set_copy(cgi->hdf, PRE_OUTPUT".uname", PRE_QUERY".uname");
}
